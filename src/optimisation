Thibaud
 ****************
 * INTRODUCTION *
 ****************
 * Pour rendre l'envoi et la réception asynchrones et donc pouvoir envoyer les paquest par fenêtre,
 * il faut d'abord modifier la fonction sendFile pour découpler l'envoi et la réception des paquets.
 * Ici, le chargement du paquet, l'envoi du paquet, la réception de l'aquittement, le renvoi du paquet en cas d'éhec et enfin le vidage du buffer est synchrone.
 * Tout doit être asynchrone, donc pouvant être parallélisé afin d'améliorer les performances.
 * À faire :
 * 	1. Utiliser une map pour créer une file _toSend de paquets déjà préparé pour l'envoi. Chaque élement de la structure contiendra le numéro du paquet ainsi que le segment à envoyer
 *  2. Paralléliser la préparation de la file des segmnents et l'envoi des paquets
 *  3. Vider de la file dès qu'un paquet est envoyé pour le placer dans une autre file _sent (cette file est comme _toSend, une map id:segment)
 *  4. Changer le fonctionnement du handle pour replacer les paquets sans ack dans une troisième file _toResend (pareil que les autres, une map id:segment)
 *	5. Vider de la file _sent et les paquets bien reçus
 * Normalement pour faire cela, il faut 2/3 goroutines, une pour l'envoi et une pour la gestion des ack et peut être une pour le chargement du fichier dans la file _toSend. Ces goroutines doivent discuter entres elle pour prévenir quand un ack n'est pas reçu
 * Le plus importamt pour les performances est la partie 2-5 c'est à dire paralléliser réception et envoi, la parallélisation de la préparation des paquets a moins d'impacts
 *
 **************
 * PSEUDOCODE *
 **************
 * 1. func loadToBuffer(fileName string) map[int][]byte => charge le fichier dans la file _toSend
 *
 * 2-3. func sendFile(conn *net.UDPConn, fileName string, addr *net.UDPAddr, _toSend *map[int][]byte, _toResend *map[int][]byte) =>  Pour chaque segment dans _toResend ou _toSend (si _toResend vide) envoie un paquet et le place dans _sent. Attention à gérer le cas si _toSend est aussi vide car pas remplis assez vite et à ne pas trop envoyer de paquets si _sent est plein
 *
 * 4-5. func handleAck(conn *net.UDPConn, header string, addr *net.UDPAddr, _sent *map[int][]byte)) => Pour chaque segment dans _sent, vérifie si l'ack est reçu. si oui vide le segment de _sent, sinon rajoute le segment dans _toResend.
 *
 * En parralélisant, vous ferez face au problème de producer-comsummer pour _toSend, _sent et _toResend. Voici 2 liens pour le résoudre en Go:  https://www.golangprograms.com/illustration-of-producer-consumer-problem-in-golang.html, https://betterprogramming.pub/hands-on-go-concurrency-the-producer-consumer-pattern-c42aab4e3bd2.
 * Les fonctions du dessus sont là pour illustrer le fonctionnement, les paramètres sont faux car vous devrez utiliser des channels. Les éventuels return ne sont pas présents non plus.
 * Pour ajouter les fenêtres, le même fonctionnement est gardé mais on envoie par salve de la taille de la fenêtre au lieu de faire 1 par 1. Autrement dit, sendFile attends que _toSend ou _toResend ait une taille de n avant d'envoyer n paquets en même temps.
 *
 **********
 * ASTUCE *
 **********
 * Pour augmenter un peu la vitesse de transfert, le chunk size peut être augmenté vers 1500 bytes sans trop de soucis, vous réduirez donc le nombre de paquet à envoyer, mais en augmentant le taux d'erreur. Il vaut mieux tester mais les normes ethernet sont à 1500 bytes de payload donc normalement c'est bon.
